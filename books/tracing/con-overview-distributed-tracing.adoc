// Module included in the following assemblies:
//
// assembly-distributed-tracing.adoc

[id='con-overview-distributed-tracing-{context}']
= Overview of distributed tracing

Distributed tracing allows developers and system administrators to track the progress of transactions between applications (and services in a microservice architecture) in a distributed system. This information is useful for monitoring application performance and investigating issues with target systems and end-user applications.

In {ProductName}, distributed tracing facilitates the end-to-end tracking of messages: from source systems to the Kafka cluster and then to target systems and applications.

As an aspect of system observability, distributed tracing complements the metrics that are available to view in xref:con-metrics-kafka-exporter-grafana-{context}[Grafana] dashboards and the available loggers for each component.

== OpenTracing and Jaeger

The {OpenTracingHome} and {JaegerHome} projects are used to implement distributed tracing in {ProductName}.

.OpenTracing

The OpenTracing specification defines APIs that developers can use to instrument applications for distributed tracing. When you instrument an application, you add instrumentation code in order to monitor the execution of individual transactions. When instrumented, applications generate __traces__ when individual transactions occur. Traces are composed of __spans__, which define specific units of work.

To simplify the instrumentation of Kafka clients, {ProductName} includes the https://github.com/opentracing-contrib/java-kafka-client/blob/master/README.md[OpenTracing Apache Kafka Client Instrumentation^] library.

NOTE: The OpenTracing project is merging with the OpenCensus project. The new, combined project is named {OpenTelemetryHome}. OpenTelemetry will provide compatibility for applications that are instrumented using the OpenTracing APIs.

.Jaeger

Jaeger, a tracing system, is an implementation of the OpenTracing APIs used for monitoring and troubleshooting microservices-based distributed systems. It provides client libraries for instrumenting applications.

Jaeger samples an application's traces, based on a set sampling strategy, and then visualizes them in a user interface. You can use this to visualize, query, filter, and analyze trace data.

.An example of a query in the Jaeger user interface

image:image_con-overview-distributed-tracing.png[Simple Jaeger query]

//== Distributed tracing support in {ProductName}

//In {ProductName} on {ProductPlatformName}, distributed tracing is supported in:

//* Kafka Producers
//* Kafka Consumers
//* Kafka Streams API applications
//* Kafka Connect
//* Mirror Maker 
//* Kafka Bridge

//To enable distributed tracing in these clients and components, you instrument application code using the OpenTracing Apache Kafka Client Instrumentation library.
//When instrumented, these clients generate traces for messages--for example, when producing messages or writing offsets to the log.

//Traces are sampled according to a sampling strategy and then visualized in the Jaeger user interface. This trace data is useful for monitoring the performance of your Kafka cluster and debugging issues with target systems and applications.

.Tracing in Mirror Maker
For Mirror Maker, messages are traced from the source cluster to the target cluster; the trace data records messages entering and leaving the Mirror Maker component.

.Tracing in Kafka Connect
Only messages produced and consumed by Kafka Connect itself are traced. To trace messages sent between Kafka Connect and external systems, you must configure tracing in the connectors for those systems. For more information, see xref:assembly-kafka-connect-{context}[].

.Tracing in the Kafka Bridge
Messages produced and consumed by the Kafka Bridge are traced. Incoming HTTP requests from client applications to send and receive messages through the Kafka Bridge are also traced. In order to have end-to-end tracing, you must configure tracing in your HTTP clients.
